# shellcheck shell=bash

# Make MacOS shut up about zsh
export BASH_SILENCE_DEPRECATION_WARNING=1

# Enable homebrew's bash completion if installed
[[ -r "/opt/homebrew/etc/profile.d/bash_completion.sh" ]] &&
	. "/opt/homebrew/etc/profile.d/bash_completion.sh"

# Load Learning on Screen constants (Server addresses, API Keys, etc)
# shellcheck source=/Users/nicholas/.bash_los_constants
source ~/.bash_los_constants

# AWS SSO Helpers
source $MYDIR/bash/lib/aws_sso.lib.bash

# Set default AWS profile
export AWS_PROFILE=LoS-Dev

function los-Protectotron() {
	SYSTEM=${1:-systems}

	RED='\033[0;31m'
	NC='\033[0m' # No Color
	BOLD='\033[1m'
	UNDERLINE='\033[4m'

	echo -e "${RED}WARNING: Using ${BOLD}${UNDERLINE}PRODUCTION${NC}${RED} $SYSTEM endpoint${NC}"
	RANDOM_WORDS=$(random_words 3)
	echo -e "[Protectotron] To proceed, please type the following words: ${BOLD}$RANDOM_WORDS${NC}"
	read -rp "> " USER_INPUT
	if [[ "$USER_INPUT" != "$RANDOM_WORDS" ]]; then
		echo -e "[Protectotron] ${RED}Input did not match. Aborting.${NC}"
		return 1
	fi

}

function aws-port-forward-prod-readonly() {
	RDS=${1:-$LOS_PROD_RDS_RO_ENDPOINT}
	PORT=${2:-3306}
	BASTION=$LOS_PROD_BASTION_INSTANCE
	AWS_PROFILE=LoS-Prod

	aws-login "$AWS_PROFILE"
	aws ssm start-session \
		--profile "$AWS_PROFILE" \
		--target "$BASTION" \
		--document-name AWS-StartPortForwardingSessionToRemoteHost \
		--parameters host="$RDS",portNumber="$PORT",localPortNumber="$PORT"
}

function aws-port-forward-prod-write() {
	RDS=${1:-$LOS_PROD_RDS_RW_ENDPOINT}
	PORT=${2:-3306}
	BASTION=$LOS_PROD_BASTION_INSTANCE
	AWS_PROFILE=LoS-Prod

	los-Protectotron "RDS Writable" || return 1

	aws-login "$AWS_PROFILE"
	aws ssm start-session \
		--profile "$AWS_PROFILE" \
		--target "$BASTION" \
		--document-name AWS-StartPortForwardingSessionToRemoteHost \
		--parameters host="$RDS",portNumber="$PORT",localPortNumber="$PORT"
}

function aws-port-forward-dev() {
	RDS=${1:-$LOS_DEV_RDS_ENDPOINT}
	PORT=${2:-3306}
	BASTION=$LOS_DEV_BASTION_INSTANCE
	AWS_PROFILE=LoS-Dev
	aws-login "$AWS_PROFILE"
	aws ssm start-session \
		--profile "$AWS_PROFILE" \
		--target "$BASTION" \
		--document-name AWS-StartPortForwardingSessionToRemoteHost \
		--parameters host="$RDS",portNumber="$PORT",localPortNumber="$PORT"
}

function los-stack-prod {
	if [ -z "$1" ]; then
		echo "[LoS-Stack-Prod] Usage: los-stack-prod command"
		return 1
	fi
	los-stack "$1" prod . "$LOS_PROD_ACCOUNT_ID" "LoS-Prod"
}

function los-stack-dev {
	if [ -z "$1" ]; then
		echo "[LoS-Stack-Dev] Usage: los-stack-dev command"
		return 1
	fi
	los-stack "$1" dev . "$LOS_DEV_ACCOUNT_ID" "LoS-Dev"
}

function los-access-container-dev() {
	SERVICE_NAME=$1
	CLUSTER_NAME=dev-$1
	if [ -z "$SERVICE_NAME" ]; then
		echo "[LoS-Access-Container-Dev] Usage: los-access-container-dev service_name"
		echo "Services:"
		aws ecs list-clusters --output text | cut -d "-" -f 4-
		return 1
	fi
	TASK_ARN=$(aws ecs list-tasks --cluster "$CLUSTER_NAME" --query 'taskArns[0]' --output text)
	TASK_ID=$(echo "$TASK_ARN" | awk -F '/' '{print $3}')

	aws ecs execute-command --cluster "$CLUSTER_NAME" --task "$TASK_ID" --container "$SERVICE_NAME" --command "/bin/bash" --interactive
	echo aws ecs execute-command --cluster "$CLUSTER_NAME" --task "$TASK_ID" --container "$SERVICE_NAME" --command "/bin/bash" --interactive
}

function los-stack {

	if [ -z "$1" ]; then
		echo "[LoS-Stack] Usage: los-stack command [env] [path] [account_id] [region]"
		return 1
	fi

	if [ -z "$(command -v ts)" ]; then
		echo "[LoS-Stack] Please install 'moreutils' to use the 'ts' command for timestamping output."
		return 1
	fi

	COMMAND=${1:-plan}
	ENV=${2:-dev}
	STACKPATH=$(grealpath "${3:-.}")
	ACCOUNT_ID=${4:-$LOS_DEV_ACCOUNT_ID}
	STACK_AWS_PROFILE=${5:-LoS-Dev}
	REGION=${6:-eu-west-2}

	if [[ ! -d $STACKPATH ]]; then
		echo "[LoS-Stack] Stack path $STACKPATH does not exist or is not a directory"
		return 1
	fi

	TERRAFORM_FILES_FOUND=$(find "$STACKPATH" -maxdepth 1 -name "*.tf" | wc -l)
	if [[ $TERRAFORM_FILES_FOUND -eq 0 ]]; then
		echo "[LoS-Stack] No Terraform files found in $STACKPATH"
		return 1
	fi

	if [[ $COMMAND != "plan" && $COMMAND != "apply" && $COMMAND != "destroy" && $COMMAND != "validate" && $COMMAND != "fmt" && $COMMAND != "output" ]]; then
		echo "[LoS-Stack] Invalid command: $COMMAND"
		echo "Valid commands are: plan, apply, destroy, validate, fmt, output"
		return 1
	fi

	if [[ $ENV == "prod" && $COMMAND != "plan" ]]; then
		los-Protectotron "Terraform" || return 1
	fi

	git fetch --tags origin main
	if [[ $ENV == "prod" ]]; then
		BITBUCKET_TAG=$(git describe --tags --abbrev=0 origin/main)
	else
		GIT_UPSTREAM_BRANCH=$(git for-each-ref --format='%(upstream:short)' "$(git symbolic-ref -q HEAD)")
		BITBUCKET_TAG=$(git rev-parse "$GIT_UPSTREAM_BRANCH")
		if [[ -z "$BITBUCKET_TAG" ]]; then
			echo "[LoS-Stack] Could not determine latest commit on upstream branch $GIT_UPSTREAM_BRANCH"
			exit 1
		fi
		GIT_CURRENT_COMMIT=$(git rev-parse HEAD)
		if [[ "$BITBUCKET_TAG" != "$GIT_CURRENT_COMMIT" ]]; then
			echo "[LoS-Stack] Warning: Current commit $GIT_CURRENT_COMMIT does not match latest commit on upstream branch $GIT_UPSTREAM_BRANCH ($BITBUCKET_TAG)"
			echo "Are you sure about this?"
			read -rp "> " CONFIRM
			if [[ "$CONFIRM" != "yes" ]]; then
				echo "[LoS-Stack] Aborting."
				return 1
			fi
		fi
	fi

	if [[ -z "$BITBUCKET_TAG" ]]; then
		echo "[LoS-Stack] Could not determine BITBUCKET_TAG, using default"
	else
		echo "[LoS-Stack] Using BITBUCKET_TAG: $BITBUCKET_TAG"
		export ADDITIONAL_TERRAFORM_FLAGS=-var="image_tag=${BITBUCKET_TAG}"
	fi

	STARTPATH=$(
		pwd
	)
	aws-login "$STACK_AWS_PROFILE"

	OLD_AWS_PROFILE=$AWS_PROFILE
	export AWS_PROFILE=$STACK_AWS_PROFILE

	if [ ! -f Makefile ]; then
		echo "[LoS-Stack] No Makefile found in current directory"
		MAKE_DIR=$(find-up Makefile "$STACKPATH")
		if [ -z "$MAKE_DIR" ]; then
			echo "[LoS-Stack] No Makefile found in any parent directory"
			return 1
		else
			STACKPATH=$(grealpath --relative-to="$MAKE_DIR" "$STACKPATH")
			echo "[LoS-Stack] Found Makefile in $MAKE_DIR, changing to that directory"
			echo "[LoS-Stack] New Stack Path: $STACKPATH"
			cd "$MAKE_DIR" || return 1
		fi
	fi

	if [[ ! -f $STACKPATH/terraform.tf ]]; then
		echo "[LoS-Stack] No terraform.tf found in $STACKPATH"
		return 1
	fi

	STACKPATH=${STACKPATH#"terraform/"} # Remove leading terraform/ if present

	{
		echo make "$COMMAND" ENV="$ENV" STACK="$STACKPATH" ACCOUNT_ID="$ACCOUNT_ID" REGION="$REGION"
		echo "[LoS-Stack] Current directory is $(pwd)"
		make "$COMMAND" ENV="$ENV" STACK="$STACKPATH" ACCOUNT_ID="$ACCOUNT_ID" REGION="$REGION"
	} | ts

	cd "$STARTPATH" || return 1
	export AWS_PROFILE=$OLD_AWS_PROFILE
}

# Alias for sourcing Granted's assume script
alias assume=". assume"

# Alias for sourcing chtf
if [[ -f /opt/homebrew/share/chtf/chtf.sh ]]; then
	source /opt/homebrew/share/chtf/chtf.sh
fi
