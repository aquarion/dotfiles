# ~/.bash_profile: executed by bash(1) for login shells.
# see /usr/share/doc/bash/examples/startup-files for examples.
# the files are located in the bash-doc package.

# the default umask is set in /etc/login.defs
#umask 022

# include .bashrc if it exists
if [ -f ~/.bashrc ]; then
    . ~/.bashrc
fi

if hash gsed 2>/dev/null; then
    alias sed=gsed
fi

if [ "$(uname)" == "Darwin" ]; then
    export ARCH="darwin-amd64";
elif [[ `uname -i` -eq "x86_64" ]];
then
    export ARCH="linux-amd64";
elif [[ `uname -i` -eq "i686" ]];
then
    export ARCH="linux-386";
fi

if hash brew 2>/dev/null; then
    if [ -f $(brew --prefix)/etc/bash_completion ]; then
        HAS_BREW=Yes
    fi
fi

if [[ -d ~/code ]]; then
    MYDIR=~/code/dotfiles
else
    MYDIR=`find ~ -name dotfiles -type d -print -quit`
fi

if [[ $HAS_BREW = "Yes" ]]; then
    . $(brew --prefix)/etc/bash_completion
elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
elif [ -f ~/.git_bash_completion ]; then
    . ~/.git_bash_completion
fi

if [ -f ~/.git-prompt.bash ]; then
    . ~/.git-prompt.bash
fi


export MYDIR=$MYDIR

. $MYDIR/bash/git_completion.bash
. $MYDIR/bash/bash_colours

# set PATH so it includes user's private bin if it exists
if [ -d ~/bin ] ; then
    PATH=~/bin:"${PATH}"
fi

# do the same with MANPATH
if [ -d ~/man ]; then
    MANPATH=~/man${MANPATH:-:}
    export MANPATH
fi

export EDITOR=vim

GIT_PS1_SHOWDIRTYSTATE=true

export LS_OPTIONS='--color=auto'
export CLICOLOR='Yes'
export LSCOLORS=gxfxbEaEBxxEhEhBaDaCaD

function ps1_git_state {

    if hash __git_ps1 2>/dev/null; then
        true
    else
        return
    fi

    GITSTATE=$(__git_ps1 " (%s)")
    if [[ $GITSTATE =~ \*\)$ ]]
    then
        echo -e "\001$Yellow\002$GITSTATE"
    elif [[ $GITSTATE =~ \+\)$ ]]
    then
        echo -e "\001$Purple\002$GITSTATE"
    else
        echo -e "\001$Cyan\002$GITSTATE"
    fi
}

export PS1="\[$Cyan\]\u\[$White\]@\[$Green\]\h \[$Blue\]\w\[$White\]\$(ps1_git_state):\[$Color_Off\] "

alias ll='ls -lah'
alias gg='git status -s'

function viewssl {
	echo | openssl s_client -showcerts -servername $1 -connect $1:443 2>/dev/null | openssl x509 -inform pem -noout -text
}
function c {
    PROJECTDIR=$(find ~/code/ -maxdepth 1 \( -type l -or -type d \) -iname \*$1\* -print -quit);
    if [ $PROJECTDIR ];
    then
        echo -n "🔍 "
        pushd $PROJECTDIR
    else
        echo "😞"
    fi
}
function p {
    PROJECTDIR=$(find ~/code/ -maxdepth 2 \( -type l -or -type d \) -iname \*$1\* -print -quit);
    if [ $PROJECTDIR ];
    then
        echo -n "🔍 "
        pushd $PROJECTDIR
    else
        echo "😞"
    fi
}

function h {
    PROJECTDIR=$(find -L ~/hosts/ -maxdepth 3 \( -type l -or -type d \) -iname \*$1\* -print -quit);
    if [ $PROJECTDIR ];
    then
        echo -n "🔍 "
        pushd $PROJECTDIR
    else
        echo "😞"
    fi
}

function f {
    FOUND=$(find -L . -type f -iname \*$1\* -print -quit);
    if [ $FOUND ];
    then
        echo -n "🔍 "
        pushd `dirname $FOUND`
    else
        echo "😞"
    fi
}

function tower {
    if [[ $1 ]];
    then
        pushd `dirname $1`
    fi
    DIR=$(git rev-parse --show-toplevel)
    DIRFAIL=$?

    if [[ $DIRFAIL -gt 0 ]]
    then
        echo "$DIR Not a git directory"
        return
    fi


    gittower $DIR
}

function dailyphoto_convert {
    echo "> Resize $1 to become $2"
    convert "$1" -resize 2000x "$2"
    echo "> Squish $2 (This will take a while)"
    guetzli "$2" "$2"
    echo "Done!"

}

[[ -s "$HOME/.rvm/scripts/rvm" ]] && . "$HOME/.rvm/scripts/rvm"  # This loads RVM into a shell session.
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

if [[ -e /usr/local/bin/virtualenvwrapper.sh && -e /usr/local/bin/python3 ]];
then
    export VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python3
    source /usr/local/bin/virtualenvwrapper.sh
fi
#`echo $- | grep -qs i` && byobu-launcher && exit 0

# MacPorts Installer addition on 2014-02-25_at_12:26:12: adding an appropriate PATH variable for use with MacPorts.
export PATH=/opt/local/bin:/opt/local/sbin:$PATH
# Finished adapting your PATH environment variable for use with MacPorts.

if [ -d /Applications/Visual\ Studio\ Code.app ]; then
    PATH="$PATH:/Applications/Visual Studio Code.app/Contents/Resources/app/bin"
fi

if [ -d $HOME/Library/Python/2.7/bin ]; then
    PATH="$PATH:$HOME/Library/Python/2.7/bin"
fi

if [ -d $HOME/.config/composer/vendor/bin ]; then
    PATH="$PATH:$HOME/.config/composer/vendor/bin"
fi

if [ -d $HOME/.local/lib/aws/bin ]; then
    PATH="$PATH:$HOME/.local/lib/aws/bin"
    complete -C "$HOME/.local/lib/aws/bin/aws_completer" aws
fi

if [[ -d  /opt/homebrew ]]; then # New Homebrew directory
    PATH="/opt/homebrew/bin:/opt/homebrew/sbin:$PATH"
    MANPATH="$MANPATH:/opt/homebrew/manpages"
    export MANPATH
fi

export PATH=$PATH:$MYDIR/bin

export ORIGINAL_PATH=$PATH

# Remove duplicates from PATH

function clean_path {
    echo $PATH | sed -e $'s/:/\\\n/g' | awk '!x[$0]++' | xargs -I "{}" bash -c 'test -s "{}" && echo -n "{}":' | sed 's/:$//'
}

function do_prompt_command {
        # echo "ANTP"
        # echo clean: $CLEAN_PATH
        # CLEAN_PATH=$PATH
        NEW_PATH=$CLEAN_PATH
        if [ ! -z $VIRTUAL_ENV ]; then
            # echo "VE $VIRTUAL_ENV"
            NEW_PATH=$VIRTUAL_ENV/bin:$NEW_PATH
        fi
        if `hash npm 2>/dev/null` ; then
            NPMBIN=$(npm bin)
            if [ -d "$NPMBIN" ]; then
                # echo "NPM $NPMBIN "
                NEW_PATH=$NPMBIN:$NEW_PATH
            fi
        fi

        if [[ "$NEW_PATH" != "$LAST_PATH" ]];
        then
            if `hash wdiff 2>/dev/null`; then
                tmpone=$(mktemp)
                tmptwo=$(mktemp)
                echo -ne "Path change:"
                echo $LAST_PATH | sed -e $'s/:/\\\t/g' > $tmpone
                echo $NEW_PATH  | sed -e $'s/:/\\\t/g' > $tmptwo
                wdiff --no-common $tmpone $tmptwo | colordiff | grep -v '===' | grep -v "^$"
                #rm $tmpone $tmptwo
            fi
        fi

        export PATH=$NEW_PATH
        export LAST_PATH=$PATH
}

HISTSIZE=100000
HISTFILESIZE=200000

PROMPT_COMMAND=do_prompt_command

# If you use #'s for defer and start dates, you'll need to escape the #'s or
# quote the whole string.

function task () {
  if [[ $# -eq 0 ]]; then
        echo "Usage: some task! @context ::project #defer #due //note"
    #oapen -a "OmniFocus"
  elif hash osascript 2>/dev/null; then
    osascript <<EOT
    tell application "OmniFocus"
      parse tasks into default document with transport text "$@"
    end tell
EOT
  elif [[ -d ~/Dropbox/File\ Transfer ]]; then
    echo "Send to Dropbox"
    if [[ ! -d ~/Dropbox/File\ Transfer/Omnifocus ]]; then
        mkdir ~/Dropbox/File\ Transfer/Omnifocus
    fi
    echo "$@" >> ~/Dropbox/File\ Transfer/Omnifocus/`hostname`-tasks.txt
  else
    echo "Need either to be on OSX or have Dropbox available"
  fi
}

########## Start Direnv

if `which direnv > /dev/null`;
then
        eval "$(direnv hook bash)"
else
        NOTCONF="${NOTCONF}Direnv, "
fi
########## End Direnv

########## Start Virtualenv

export WORKON_HOME=$HOME/.virtualenvs

########## End Virtualenv

if [[ -e /usr/local/bin/virtualenvwrapper.sh ]];
then
	source /usr/local/bin/virtualenvwrapper.sh
elif [[ -e /usr/bin/virtualenvwrapper.sh ]];
then
	source /usr/bin/virtualenvwrapper.sh
elif [[ -e /usr/share/virtualenvwrapper/virtualenvwrapper.sh ]];
then
	source /usr/share/virtualenvwrapper/virtualenvwrapper.sh
fi

if [[ -e ~/.bash_profile.local ]];
then
    source ~/.bash_profile.local
fi

if [[ $ARCH == "darwin-amd64" ]];
then
    LOCALE="en_GB.UTF-8"
else
    LOCALE="en_GB.utf8"
fi
LOCALELINE="$LOCALE UTF-8"
LOCALETEMP=`mktemp`

locale -a > $LOCALETEMP
if grep -i $LOCALE $LOCALETEMP > /dev/null;
then
    export LC_ALL=$LOCALE
    export LANG=$LOCALE
    export LANGUAGE=$LOCALE
else
    echo "Couldn't set Locale to $LOCALE"
    echo "sudo su -c \"echo $LOCALELINE >> /etc/locale.gen && locale-gen\""
fi

rm $LOCALETEMP


# export AWS_DEFAULT_REGION=eu-west-1

export CLEAN_PATH=`clean_path`
export LAST_PATH=$CLEAN_PATH
